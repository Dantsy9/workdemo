# maven

## 什么是maven？

项目管理和构建的工具。

## 依赖范围

在jar包依赖导入时用<scope>...<scope>标签设置作用范围，默认是compile，格式如：

<scope>test<scope>（测试范围内有效），案例Jnuit，基本上Junit都要设置为test

<scope>compile<scope>（主程序，测试，打包有效），

<scope>provided<scope>（测试，主程序有效），

<scope>test<scope>（测试，打包有效）

## 生命周期

maven有三套**相互独立**的生命周期

- clean：清理工作，如clean
- default：核心工作，如compile编译，test测试，package打包，intsall安装jar包到本地仓库
- site(少使用)：生成报告，发布站点，如site

# springboot

## 什么是spring？

spring包括许多框架，例如 Spring framework、SpringMVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等.

## Http

### 概念

超文本传输协议，规定了浏览器和服务器之间数据传输的规则

### 特点

1. 基于TCP协议：面向连接，安全
2. 基于请求-响应模型：一次请求对应一次响应
3. HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的
   - 缺点：多从请求间不能共享数据
   - 有点：速度快

### 请求报文构成

1. 请求行：包括请求方法、URL、协议/版本
2. 请求头(Request Header)
3. 请求正文

### 响应报文构成

1. 状态行
2. 响应头
3. 响应正文

### 常见请求方法

- GET:请求指定的页面信息，并返回实体主体。
- POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
- PUT:从客户端向服务器传送的数据取代指定的文档的内容。
- DELETE:请求服务器删除指定的页面。

### post和get的区别：

- 都包含请求头请求行，post多了请求body。
- get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。
- GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。
- GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。

## Https

### 一般http中存在如下问题：

- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改
- 没有验证对方身份，存在冒充危险

### 什么是HTTPS?

为了解决上述HTTP存在的问题，就用到了HTTPS。

HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

### HTTPS的缺点

- HTTPS协议多次握手，导致页面的加载时间延长近50%；
- HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；
- 申请SSL证书需要钱，功能越强大的证书费用越高。
- SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。

## 总结HTTPS和HTTP的区别

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。
- http和https使用连接方式不同，默认端口也不一样，http是80，https是443。

## 分层解耦-三层结构-IOC&DI

### 三层架构

​	前端访问顺序，从上至下

- Controller：控制层，接受前端发送的请求，对请求进行处理，并相应数据
- Service：业务逻辑层，处理具体的业务逻辑
- Dao：数据访问层（持久层），负责数据访问操作，包括数据的增删改查

### 分层解耦

- 内聚

  软件中各个功能模块内部的功能联系

- 耦合

  衡量软件中各个层/模块之间的依赖、关联的程度

- 软件设计原则：高内聚低耦合

### IOC

控制反转，对象的创建控制权由程序自身转移到外部（容器）//@Component

### DI

容器为应用程序提供运行时，提供所依赖的资源，称之为依赖注入

- @Autowired注解，默认是按照类型进行的，如果存在多个相同类型的bean，就会报错
- 可以通过以下几种注解完成
  - @Primary //设置bean的优先级，放在service下的类前
  - @Qualifier  //放在controller下的@Autowired前在()内放置bean名字设置优先级
  - @Resource(name = ”bean名字“) //直接替换@Autowired，直接指定bean，是jdk提供的注解

### bean

IOC容器中创建管理的对象

## 过滤器Filter

### 概念

- 是javaweb三大组件之一
- 可以对资源的请求拦截下来，从而实现一些特殊的功能
- 一般完成一些通用操作，比如：登录校验、统一编码处理、敏感字符处理等

![](C:\Users\V\Desktop\临时文件\过滤器原理.png)

### 快速入门

1. 定义Filter:定义一个类，实现Filter接口，并重写所有方法

2. 配置Filter : filter类上加@WebFilter注解，配置拦截资源的路径。引导类上加@ServletComponentScan开启Servlet组件支持

   ```java
   @WebFilter(urlPatterns = "/*") //要被拦截url，/*为全部
   public class FullNameFilter implements Filter {
   
       @Override
       public void init(FilterConfig filterConfig) throws ServletException {//初始化方法，Web服务器启动，创建Filter时调用，只调用一次
           Filter.super.init(filterConfig);
       }
   
       @Override
       public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {//拦截到请求时调用，可多用调用
           System.out.println("拦截执行，拦截到了请求：");
           //拦截后的放行操作
           chain.dofilter(requrst,response);//访问对应资源
       }
   
       @Override
       public void destroy() {//销毁方法，服务器关闭时调用，只调用一次，做资源释放，环境清理工作
           Filter.super.destroy();
       }
   }
   ```

### 执行流程

```java
@Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {//拦截到请求时调用，可多用调用
        System.out.println("拦截执行，拦截到了请求：，放行前逻辑");
        //拦截后的放行操作
        chain.dofilter(requrst,response);//访问对应资源
        //拦截后的放行操作
        System.out.println("拦截执行，拦截到了请求： ，放行后逻辑");
    }
```

![](C:\Users\V\Desktop\临时文件\执行流程图.png)

- 放行后访问对应资源，资源访问完毕后，还会回到Filter中
- 回到Filter中，重新执行放行后逻辑

拦截路径（urlPatterns = “/*”）、

拦截具体路径		/login		只有访问/login路径时，才会被拦截

目录拦截				/emps/*   访问/emps下的所有资源，都会被拦截

拦截所有				/*

### 过滤器链

介绍：一个web应用可以配置多个过滤器，多个过滤器形成了一个过滤器链

![](C:\Users\V\Desktop\临时文件\过滤器链.png)

顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序

当第一个过滤器运行到chain.dofilter命令时，则会先跳转到第二个过滤器进行拦截操作（以此类推有第三个先进行第三个的拦截操作）；第二个过滤器拦截后的放行操作完成后再回到上一个过滤器继续完成放行操作到结束。

### JWT

1. 简介

   - 定义了一种简洁的，自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。
   - 组成：
     - 第一部分：Header（头），记录令牌类型、签名算法等。例如{“alg”:"HS256","type":"JWT"}
     - 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如{“id”:"1","username":"tom"}
     - 第三部分：Signature（签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。

2. 生成和校验

   生成部分

   ```java
       public void testJwt(){//创建令牌
           HashMap<String, Object> claims = new HashMap<>();
           claims.put("id",1);
           claims.put("name","tom");
   
           String jwt = Jwts.builder()
                   .signWith(SignatureAlgorithm.HS256,"hotkey")//签名算法
                   .setClaims(claims)//自定义内容，载荷
                   .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000))//设置有效期,这里为一个小时
                   .compact();//字符串输出
           System.out.println(jwt);
       }
   ```

   校验部分

   ```java
       public void testhotkey(){//解析令牌
           Claims claims = Jwts.parser()
                   .setSigningKey("hotkey")//令牌名
                   .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTY5MDc0NjA2OH0.7u5JRXL-yvByjK0yy8rKrR2a-dNliYWFaIgW4JIrMJk")//这里是上面生成的令牌
                   .getBody();//转换成string
           System.out.println(claims);
       }
   ```

3. 登录后下发令牌

   

### 登录校验-Filter

- 流程
  - 获取请求的url
  - 判断请求中是否包含login，如果包含，就说明是登录操作，放行
  - 获取请求头中的令牌(token)
  - 判断令牌是否存在，如果不存在返回错误结果（未登录）
  - 解析token，如果解析失败，返回错误结果（未登录）
  - 都成功，放行。

```java
@Slf4j
@WebFilter("/path/login")
public class LoginFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) servletRequest; //对请求进行强转
        HttpServletResponse rep = (HttpServletResponse) servletResponse;
        //        - 获取请求的url
        String url = req.getRequestURI().toString(); //转换成字符串
        log.info("请求的url：" , url);
//                - 判断请求中是否包含login，如果包含，就说明是登录操作，放行
        if(url.contains("login")){
            log.info("登录操作，放行");
            filterChain.doFilter(servletRequest,servletResponse);
        }
//                - 获取请求头中的令牌(token)
        String jwt = req.getHeader("token");
//                - 判断令牌是否存在，如果不存在返回错误结果（未登录）
        if(!StringUtils.hasLength(jwt)){ //查询字符串是否有长度
            log.info("请求头为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            String notLogin =  JSONObject.toJSONString(error);//通过JSON这个方法将string转为json
            rep.getWriter().write(notLogin);
            return;
        }

//        - 解析token，如果解析失败，返回错误结果（未登录）
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {
            e.printStackTrace();
            log.info("解析令牌失败，返回错误信息");
            Result error = Result.error("NOT_LOGIN");
            String notLogin =  JSONObject.toJSONString(error);//通过JSON这个方法将string转为json
            rep.getWriter().write(notLogin);
            return;
        }
//        - 都成功，放行。
        log.info("登录成功");
        filterChain.doFilter(servletRequest,servletResponse);
    }
}
```

其中的Result

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Integer code;//响应码，1 代表成功; 0 代表失败
    private String msg;  //响应信息 描述字符串
    private Object data; //返回的数据

    //增删改 成功响应
    public static Result success(){
        return new Result(1,"success",null);
    }
    //查询 成功响应
    public static Result success(Object data){
        return new Result(1,"success",data);
    }
    //失败响应
    public static Result error(String msg){
        return new Result(0,msg,null);
    }
}
```

## 拦截器Interceptor

### 简介

概念：是一种动态拦截方法调用的机制，类似于过滤器。spring框架提供

作用：拦截请求，在指定的方法调用前后，根据事务需要执行预先设定的代码

### 入门

1. 定义拦截器，实现Handlertinterceptor接口，并重写其中所有方法

   ```java
   package com.example.interceptor;
   
   import org.springframework.stereotype.Component;
   import org.springframework.web.servlet.HandlerInterceptor;
   import org.springframework.web.servlet.ModelAndView;
   
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   
   @Component
   public class LoginCheckInterceptor implements HandlerInterceptor {
       @Override  //目标方法执行前执行，返回ture，放行；反之不放行
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           System.out.println("preHandle......");
           return false;
       }
   
       @Override  //目标方法执行后执行
       public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
   
           System.out.println("postHandle......");
       }
   
       @Override  //视图渲染完成后运行，最后运行
       public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
   
           System.out.println("afterCompletion......");
       }
   }
   
   ```

2. 注册拦截器

   ```java
   package com.example.config;
   
   import com.example.interceptor.LoginCheckInterceptor;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
   
   @Configuration//当前类是配置类
   public class WebConfig implements WebMvcConfigurer {
   
       @Autowired
       private LoginCheckInterceptor  loginCheckInterceptor;
   
       @Override
       public void addInterceptors(InterceptorRegistry registry) {
           //注册拦截器方法
           registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**");//拦截全部资源
       }
   }
   
   ```

### 详解

1. 拦截路径

   可以根据路径拦截资源

   ```java
   registry.addInterceptor(loginCheckInterceptor).addPathPatterns("/**").excludePathPatterns("/login");
   												//需要拦截的资源           不需要拦截的资源
   ```

   | 拦截路径  | 含义                    | 举例                                       |
   | --------- | ----------------------- | ------------------------------------------ |
   | /*        | 拦截一级目录            | /login,/dept但是不能拦截dept/1这样的路径   |
   | /**       | 拦截任意路径            |                                            |
   | /login/*  | 拦截login包下的一级路径 | 能匹配/login/1，不能匹配/login，/login/1/2 |
   | /login/** | 拦截login包下的全部路径 | 包括/login，/login/1，login/1/2            |

2. 执行流程

![](C:\Users\V\Desktop\笔记\拦截器执行流程.jpg)

Filter和Interceptor

- 接口规范不同：过滤器需要实现Filter接口，interceptor需要实现handleinterceptor接口
- 拦截范围不同：过滤器会拦截全部资源，而intrceptor只会拦截spring环境中的资源

### 登录校验

```java
package com.example.interceptor;

import com.alibaba.fastjson.JSONObject;
import com.example.pojo.Result;
import com.example.utils.JwtUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Slf4j
@Component
public class LoginCheckInterceptor implements HandlerInterceptor {
    @Override  //目标方法执行前执行，返回ture，放行；反之不放行
    public boolean preHandle(HttpServletRequest req, HttpServletResponse rep, Object handler) throws Exception {
        //        - 获取请求的url
        String url = req.getRequestURI().toString(); //转换成字符串
        log.info("请求的url：{}" , url);
//                - 判断请求中是否包含login，如果包含，就说明是登录操作，放行
        if(url.contains("login")){
            log.info("登录操作，放行");
            return true;
        }
//                - 获取请求头中的令牌(token)
        String jwt = req.getHeader("token");
//                - 判断令牌是否存在，如果不存在返回错误结果（未登录）
        if(!StringUtils.hasLength(jwt)){ //查询字符串是否有长度
            log.info("请求头为空，返回未登录的信息");
            Result error = Result.error("NOT_LOGIN");
            String notLogin =  JSONObject.toJSONString(error);//通过JSON这个方法将json转为string
            rep.getWriter().write(notLogin);
            return false;
        }
//        - 解析token，如果解析失败，返回错误结果（未登录）
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {
            e.printStackTrace();
            log.info("解析令牌失败，返回错误信息");
            Result error = Result.error("NOT_LOGIN");
            String notLogin =  JSONObject.toJSONString(error);//通过JSON这个方法将string转为json
            rep.getWriter().write(notLogin);
            return false;
        }
//        - 都成功，放行。
        log.info("登录成功");
        return true;
    }

    @Override  //目标方法执行后执行
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

        System.out.println("postHandle......");
    }

    @Override  //视图渲染完成后运行，最后运行
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

        System.out.println("afterCompletion......");
    }
}

```



# Mybatis

是一款优秀的持久层框架，用于简化JDBC的开发

## 快速入门

1. 使用Mybatis查询所有用户数据
   - 准备工作（创建工程，数据库表，实体类User）
   - 引入相关依赖和配置
   - 编写sql语句

## JDBC

使用java操作关系型数据库的一套api

- 官方定义的一套操作所有关系型数据库的规范，即接口
- 各个数据库厂商去实现这套接口，提供数据库驱动jar包
- 我们可以使用这套接口(jdbc)编程，真正执行的代码是驱动jar包中的实现类

## 数据库连接池

- 是个容器，负责分配和管理数据库连接(connection)
- 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个
- 释放空闲时间超过最大空闲时间的连接，来避免因为没用释放连接而引起的数据库连接遗漏

## 常用注解

- @TableName("表名")：标识实体类对应的表
- @TableId(value = "对应字段")：标识实体类主键字段
- @TableField(value = "对应字段")：标识实体类非主键字段

## 主键填充

```java
@TableId(value = "id",type = IdType.AUTO)

private Long id;
```

其中value是指定的主键字段名

type则是主键类型，其中 type = IdType.

- AUTO //数据库的id自增
- NONE //无状态，不自动填充
- INPUT //不自动填充
- ASSIGN_ID //自动填充数值类型的主键
- ASSIGN_UUID //自动填充字符串类型的主键

## 条件构造器

类似于sql语句的转换

SQL ： select * from user where id = 100

代码实现

```java
queryWrapper.eq(User::getId,100);//查询id=100的记录
service.list(queryWrapper);
```

SQL： select * from user where id = 100 or (id = 101 and name = 'user')

代码实现

```java
queryWrapper.eq(User::getId,100).or(user->
user.eq(User::getId,101).eq(User::getName,"user"));
service.list(queryWrapper);
//查询id=100或者id=101并且name=user的记录
```

常用条件

![](C:\Users\V\Desktop\临时文件\条件构造器的常用条件.png)

## 分页

​	步骤

1. 设置数据库类型
2. 设置单页分页条数限制
3. 溢出总页数后是否进行处理

```java
//使用分页
IPage<Demo04UserEntity> page = new Page<>();
page.setCurrent(1);//制定初始化的页面
page.setSize(5);//设置分页
page = userMapper.selectPaage(page,queryWrapper);
//page对象
public class Page<T> implements IPage<T> {
    private static final long serialVersion;
    protected List<T> records;
    protected long total;
    protected long size;
    protected long current;
}
```

## 事务

- 特性：原子性，一致性，隔离性，持久性

- 事务的实现

  ```
  @transactional
  public UserEntity cost(Long userId, int cost);
  ```


# Redis

## 什么是redis

redis是一个开源的使用ANSI [C](https://baike.baidu.com/item/C语言)[语言](https://baike.baidu.com/item/C语言)编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库](https://baike.baidu.com/item/数据库/103728)，并提供多种语言的API。

特点：

- 高速读写

  redis的底层是一个数组。

  redis都是一个key对应一个v的结构。

  redis采用链表法解决hash冲突。

- 丰富的数据类型

  redis通过sds对所有的数据类型进行统一存储和管理

- 原子性

  单线程模型

- 内存共享

## 架构模型

- RDB持久化
- AOF持久化
- 持久化
- 集群
- 主从复制
- 哨兵模式

# Kafka

## 什么是kafka

目前 Kafka 已经定位为一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。

## 为什么使用kafka

- 消息系统: Kafka 和传统的消息系统(也称作消息中间件)都具备系统解稿、冗余存储、流量削峰、缓冲、异步通信、扩展性、 可恢复性等功能。与此同时， Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能 。


- 存储系统: Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险 。 也正是得益于Kafka 的消息持久化功能和多副本机制，我 们可以把 Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置 为“永久”或启用主题的日志压缩功能即可 。


- 流式处理平台: Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作 

## 基本知识

一个典型的 Kafka 体系架构包括若干 Producer、若干 Broker、若干 Consumer，以及一个ZooKeeper集群。 其中 ZooKeeper是 Kafka用来负责集群元数据的管理、控制器的选举等操作的（包括集群 、 broker、主题、 分区等 内容） 。 Producer 将消息发送到 Broker，Broker 负责将收到的消息存储到磁盘中，而Consumer 负责从 Broker 订阅并消费消息。

- Broker：服务代理节点。对于 Kafka 而言， Broker 可以简单地看作一个独立的 Kafka 服务节点或 Kafka服务实例；
- Topic：Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的Topic(发送到 Kafka 集群中的每一条消息都要指定一个Topic)，而消费者负责订阅Topic并进行消费。
- Producer：消息生产者，向Broker发送消息的客户端
- Consumer：消息消费者，从Broker读取消息的客户端

## 快速入门

启动zookeeper：在kafka路径下启动cmd命令控制台，输入命令启动zookeeper集群

```apl
bin\windows\zookeeper-server-start.bat config\zookeeper.properties
```

启动kafka：在kafka路径下启动cmd命令控制台，输入命令启动kafka

```apl
bin\windows\kafka-server-start.bat config\server.properties
```

## 基础命令

```
//创建主题
kafka-topics.bat --create --bootstrap-server 
localhost:9092 --replication-factor 1 --partitions 1 --topic 
test-topic
//查看主题
kafka-topics.bat --list --bootstrap-server 
localhost:9092
```

# 多线程

## 一、概述

### 1.什么是线程？

进程想要执行任务就需要依赖线程。换句话说，就是进程中的最小执行单位就是线程，并且一个进程中至少有一个线程。

### 2.什么是多线程

有了多线程，我们就可以让程序同时做多件事情

### 3.多线程的作用

提高效率

### 4.应用场景

让多个事情同时运行就需要用到多线程

## 二、多线程的概念

### 并发

在同一时刻，让多个指令在单个CPU上**交替**执行

### 并行

在同一时刻，有多个指令在多个CPU上**同时**进行

## 三、多线程的实现方式

### ①继承Thread类的方式进行实现

Thread类是在java中创建一个新线程

将类声明为Thread的子类，该子类应重写Thread类的run方法

```java
class PrimeThread extends Thread{
    @Override
    public void run(){
        //*
    }
}
```

然后可以创建和启动这个线程

```java
	PrimeThread p = new PrimeThread();
	p.start();
```



### ②实现Runnable接口的方式进行实现

```java
class Myrun implements Runnable{
    @Override
    public viod run(){
        //*
    }
}
```

创建和启动

```java
	Myrun mr = new Myrun();
	Thread t = new Thread(mr);
	t.start();
```



### ③利用Callable接口和Future接口方式实现

```java
	/*	1.创建一个类Mycallable实现Callable接口
		2.重写call(是有返回值的，表示多线程运行的结果)
		3.创建MyCallable的对象(表示多线程要执行的任务)
		4.创建FutureTask的对象(作用管理多线程运行的结果)
		5.创建Thread类的对象，并启动(表示线程)
	*/
	class MyCallable implements Callable<Integer>{//<>表示内返回的范型
        public Integer call() throws Exception{
            //***
            return null;
        }
    }
```

```java
	class test{
        Mycallable mc = new MyCallable();
        FutureTask<Integer> ft = new FutureTask<>(mc);
        Thread t = new Thread(ft);
        t.start();
    }
```

### 三种方法的区别

|                                    | 优点                                         | 缺点                                       |
| ---------------------------------- | -------------------------------------------- | ------------------------------------------ |
| 继承Thread类                       | 编程比较简单，可以直接使用Thread类中的方法   | 可以扩展性较差，不能再继承其他的类         |
| 实现Runnable接口；实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类 | 编程相对复杂，不能直接使用Thread类中的方法 |

## 四、常见的成员方法

| 方法名称                         |                             说明                             |
| :------------------------------- | :----------------------------------------------------------: |
| String getName()                 |                       返回此线程的名称                       |
| viod setName(String name)        |           设置线程的名字（构造方法也可以设置名字）           |
| static Thread currentThread()    |                      获取当前线程的对象                      |
| static viod sleep(long time)     |               让线程休眠指定的时间，单位为毫秒               |
| setPriority(int newPriority)     | 设置线程优先级，1到10，默认为5，高优先级**不一定**能先优先执行完毕 |
| final int getPriority()          |                          获取优先级                          |
| final void setDaemon(blooean on) |      设置为守护线程，其他线程结束时，守护线程也随之结束      |
| public static viod yield()       |                      出让线程/礼让线程                       |
| public static viod join()        |                      插入线程/插队线程                       |

## 五、线程的生命周期

![](C:\Users\stayfall\Desktop\上课笔记\线程的生命周期.png)

## 六、锁

后续不一定能用得上，先不讲

## 七、线程池

### 1.核心原理

​	①创建一个池子，池子里面是空的

​	②提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可

​	③特殊情况：

​		1.当核心线程满时，再提交任务就会排队

​		2.当核心线程满，队伍满时，会创建临时线程

​		3.当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略

### 2.代码实现

​	①创建线程池

```java
        //获取线程池对象
        ExecutorService pool1 = Executors.newCachedThreadPool();

/*        public static ExecutorService newCachedThreadPool();创建一个没有上限的线程池
        public static ExecutorService newFixedThreadPool(int nThreads)创建一个有上限的线程池
*/
```

​	②提交任务

```java
        //提交任务
        pool1.submit(new MyRunnable());

```

​	③所有任务执行完毕，关闭线程池

```java
        //销毁线程池，服务器一般不销毁线程池
        pool1.shutdown();
```

### 3.自定义线程池

```java
                /*
                  参数一 核心线程数量            不能小于0
                  参数二 最大线程数              不能小于0，最大数量>=核心线程数量
                  参数三 空闲线程最大存活时间     不能小于0
                  参数四 时间单位                用TimeUnit.指定
                  参数五 任务队列                不能为null
                  参数六 创建线程工程            不能为null
                  参数七 任务的拒绝策略           不能为null
                */
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                corePoolSoze:3,//核心线程数量
                maximunPoolSize:6,//最大线程数
                keepAliveTime:60,//空闲线程最大存活时间
                TimeUnit.SECONDS,// 时间单位
                new ArrayBlockingQueue<>(3),//任务队列，有指定长度
              /*^^^^^^^^^^^^^^^^^^^^^^^^^^^
                new LinkedBlockingQueue<>() 无指定长度，无限长
            	*/
                Executors.defaultThreadFactory(),//创建线程工程
                new ThreadPoolExecutor.AbortPolicy()//任务的拒绝策略
        );
```

### 4.并行数

cpu的核心线程数量，就是最大并行数

### 5.线程池的大小

#### CPU密集型运算

​	最大并行数+1

#### I/O密集型运算

最大并行数 * 期望CPU利用率  *  [ ( CPU计算时间 + CPU等待时间  ) / ( CPU计算时间 ) ]

# Docker

## 一、docker概念

1. docker是一个开源的应用程序引擎
2. docker可以让开发者打包他们的应用及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上
3. 容器完全使用沙箱机制，相互隔离
   - 沙箱就是一个限制应用程序对系统资源的访问的运行环境。
   - 沙箱很多情况下都是实现在虚拟机（VM）中，比如Java的虚拟机JVM、Javascript的虚拟机V8引擎、Android中的虚拟机Dalvik/ART，以及以太坊的虚拟机EVM等等。具体的实现方式各有不同。
4. 容器性能开销极低

## 二、docker架构

![](C:\Users\stayfall\Desktop\上课笔记\docker框架.png)



docker:docker的客户端

daemon:守护进程，在linux安装完docker，就会存在这么一个守护进程

container:容器，就像面向对象中的对象，根据镜像文件创造的实例，是镜像运行的实体

image:镜像，就像面向对象中的类，静态的；就相当于一个root文件系统

Registry:仓库，docker hub是官方仓库，private registry则是私人仓库，即国内镜像

## 三、docker进程命令

- 启动服务命令

  ```linxu
  systemctl start docker
  ```

- 停止

  ```linxu
  systemctl stop docker
  ```

- 重启

  ```linxu
  systemctl restart docker
  ```

- 查看状态

  ```linxu
  systemctl status docker
  ```

- 开机启动

  ```linux
  systemctl enable docker
  ```

## 四、docker镜像命令

- 创建镜像

  ```
  docker build -t name
  	//-t 设置tag名 ，name为设置的名称
  ```

- 查看镜像

  ```linux
  docker images //查看本地镜像
  docker images -q//查看所有镜像ID
  ```

- 搜索

  ```linux
  docker search ***
  ```

- 拉取

  ```linux
  docker pull ***:3.0 //冒号后是版本号，如果不指定版本则默认最新版本
  //查看版本可以去hub.docker.com网站查看
  ```

- 删除

  ```linux
  docker rmi ***//***为imgID
  docker rmi 'docker images -q'//批量删除镜像
  ```

## 五、容器相关命令

- 创建容器

  ```linux
  docker run -i -t --name=** ***:** /bin/bash  //保持容器一直运行；创建终端；给容器起名；镜像名:版本号；打开一个shell脚本
  	//其中-i -t 可以合并为-it
  	//创建完会立刻进入容器内部
  	//如果容器是-it启动的，在退出容器的时候容器会自动关闭
  docker run -i -d --name=** ***:** // -d后台运行创建容器，需要通过命令进入容器，同样可以合并为-id
  	//通过这个指令创造的容器，进入容器后退出，容器依旧会存在
  ```

- 进入容器

  ```linux
  docker exec -it ** /bin/bash //**为创建容器时给容器的命名 
  ```

- 退出容器

  ```linux
  exit 
  ```

- 查看正在运行的容器

  ```linux
  docker ps
  docker ps -a //查看所有包括关闭的容器
  ```

- 关闭和启动容器

  ```
  docker stop ** //**为创建容器时给容器的命名
  docker start ** //**为创建容器时给容器的命名
  ```

- 删除容器

  ```
  docker rm ** //**为创建容器时给容器的命名
  docker rm 'docker ps -aq'  //删除所有容器，但是无法删除正在运行的容器
  ```

- 查看容器信息

  ```
  docker inspect **  //**为创建容器时给容器的命名，也可以为容器ID
  ```

## 六、数据卷

思考：

- Docker容器删除后，在容器中产生的数据还在吗？

  不在

- Docker容器和外部机器库直接交换文件吗？

  不能

- 容器之间想要进行数据交互？

  需要挂载数据卷

### 数据卷的概念

- 数据卷是宿主机(linux)的一个目录或文件(类似于磁盘的缓存，文件-->缓存中-->存储位置)
- 当容器目录或数据卷目录绑定后，对方的修改会立即同步
- 一个数据卷可以被多个容器挂载
- 一个容器也可以同时挂载多个数据卷

### 配置数据卷

创建启动容器，使用-v参数 设置数据卷

```
docker run ...... -v 宿主机目录(文件):容器内目录(文件) ...
```

注意事项：

1. 容器目录必须是绝对路径，即/开头的路径，宿主路径可以用~/date
2. 如果目录不存在，则会自动创建目录
3. 可以挂载多个数据卷

### 数据卷容器

#### 多容器进行数据交换

1. 多个容器挂载同一个数据卷

2. 数据卷容器

   保证C3挂了，c1和c2还能与数据卷相连，类似于保证措施

![](C:\Users\stayfall\Desktop\上课笔记\数据卷容器图示.png)

#### 配置数据卷容器

1. 创建C3数据卷容器，并用-v设置数据卷

   ```
   docker run -it --name=c3 -v /volume centos:7 /bin/bash
   	//路径volume系统会自动创建
   ```

2. 创建启动c1和c2，使用--volumes-from 参数设置数据卷

   ```
   docker run -it --name=c1 --volumes-from c3 centos:7 /bin/bash
   docker run -it --name=c2 --volumes-from c3 centos:7 /bin/bash
   ```


### 部署Nginx

1. 搜索nginx镜像

   ```
   docker serch nginx
   ```

2. 拉取nginx镜像

   ```
   docker pull nginx
   ```

3. 创建容器，设置端口映射，目录映射

   ```
   //在/root目录下创建nginx目录用于存储nginx数据信息
   mkdir ~/nginx
   cd ~/nginx
   mkdir conf
   cd conf
   //在conf目录下创建nginx.conf文件，粘贴以下内容
   vim nginx.conf
   ```

   ```
   #user  nobody;
   worker_processes  1;
    
   #error_log  logs/error.log;
   #error_log  logs/error.log  notice;
   #error_log  logs/error.log  info;
    
   #pid        logs/nginx.pid;
    
    
   events {
       worker_connections  1024;
   }
    
    
   http {
       include       mime.types;
       default_type  application/octet-stream;
    
       #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
       #                  '$status $body_bytes_sent "$http_referer" '
       #                  '"$http_user_agent" "$http_x_forwarded_for"';
    
       #access_log  logs/access.log  main;
    
       sendfile        on;
       #tcp_nopush     on;
    
       #keepalive_timeout  0;
       keepalive_timeout  65;
    
       #gzip  on;
    
       server {
           listen       80;
           server_name  localhost;
    
    
    
           location / {
               root   html;
               index  index.html index.htm;
           }
    
           error_page   500 502 503 504  /50x.html;
           location = /50x.html {
               root   html;
           }
    
    
       }
    
    
       # another virtual host using mix of IP-, name-, and port-based configuration
       #
       #server {
       #    listen       8000;
       #    listen       somename:8080;
       #    server_name  somename  alias  another.alias;
    
       #    location / {
       #        root   html;
       #        index  index.html index.htm;
       #    }
       #}
    
    
       # HTTPS server
       #
       #server {
       #    listen       443 ssl;
       #    server_name  localhost;
    
       #    ssl_certificate      cert.pem;
       #    ssl_certificate_key  cert.key;
    
       #    ssl_session_cache    shared:SSL:1m;
       #    ssl_session_timeout  5m;
    
       #    ssl_ciphers  HIGH:!aNULL:!MD5;
       #    ssl_prefer_server_ciphers  on;
    
       #    location / {
       #        root   html;
       #        index  index.html index.htm;
       #    }
       #}
    
   }
   ```

   ![](C:\Users\stayfall\Desktop\上课笔记\nginx.conf配置文件框架详解.png)

   	docker run -it --name=c_nginx \
   	-p 80：80 \		将容器端口80映射到宿主机的80端口上
   	-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \		将主机当前目录下的/conf/nginx.conf挂载到容器的/etc/nginx/nginx.conf配置目录
   	-v $PWD/logs:/var/log/nginx \		将主机当前目录下的logs目录挂载到容器的/var/log/nginx日志目录
   	-v $PWD/html:/usr/share/nginx/html \		使用外部机器访问nginx
   	nginx

# GitHub

## 一、版本控制

### 什么是版本控制？

1. 记录每次修改描述
2. 历史文档备份
3. 可恢复到之前的版本

### 方式

​	a.集中式版本控制工具 SVN和CVS

​	b.分布式版本控制工具 GIT

### 关于Git

​	git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理

​	![](C:\Users\stayfall\Desktop\上课笔记\git原理.png)

## 二、git的相关命令

### 配置命令

```java
	git config --global user.name "name"
	git config --global user.email "email@adress.com"
        //设置上传者的用户名和密码
    git config --global user.name
    git config --global user.email
        //查看配置信息
```

​	打开用户目录创建.bashrc文件并编辑

```
#用于输出git提交日志
alias git-log='git log --prety=oneline --all --gragh --abbrev-commit'
#用于输出当前目录所有文件和基本信息
alias ll='ls -a'
```

打开git bash 执行 source ~/.bashrc

### 获取本地仓库

1. 在电脑上任意位置创建一个空目录
2. 进入目录右键打开gitbash
3. 执行git init
4. 创建成功会看见.git文件夹

### 基础指令

![git基础命令](C:\Users\stayfall\Desktop\上课笔记\git基础命令.png)

- git add			(工作区 ---> 暂存区)
  - 命令形式 git add 单个文件名 | 通配符
    - 将所有修改加入暂存区 git add .
- git commit     (暂存区 ---> 本地仓库)
  - 作用：将暂存区内容加入本地仓库的当前分支
  - 命令形式 git commit -m '注释内容'

- git status
  - 作用：查看修改的状态(暂存区，工作区)

- git log (git-log 集成了下面参数)
  - 作用：查看提交信息
  - 命令形式 git log [参数]
    - 参数
    - --all 显示所有分支
    - --pretty=oneline 将提交的信息显示在一行
    - --abbrev-commit 使得输出的commitid更剪短
    - --gragh 以图的形式显示

- 版本回退(实际开发时慎用)
  - git reset  --hard commitID
  - commitID可以通过log指令查看

- 如何查看已经删除的记录
  - git reflog

## 分支

### 概述

几乎所有的版本控制系统都以某种形式支持分支。使用分支意味着你可以把你的工作从开发主线上分离来进行重大不过bug修改，开发新的功能，以免影响开发主线

### 基本命令

- 查看本地分支
  - git branch

- 创建本地分支
  - git branch 分支名

- ***切换分支**
  - git checkout 分支名
  - 创建并切换一个不存在的分支：git checkout -b 分支名

- ***合并分支**
  - 一个分支上的提交可以合并在另一个分支上
  - git merge 分支名字

- 删除分支
  - 不能删除 当前分支，只能删除其他分支
  - git branch -d 分支名 需要做各种检查
  - git branch -D 分支名 不做任何检查删除

### 解决分支冲突

当两个分支上对文件的修改可能存在冲突，例如同时修改了同一文件的同一行，这时就需要手动解决冲突，步骤如下：

1. 处理文件中冲突的地方
2. 将解决完的文件加入暂存区(add)
3. 提交到仓库(commit)

### 开发中分支使用原则与流程

- master（生产）分支

  线上分支，主分支，中小规模项目作为线上运行的应用对应的分支

- develop（开发）分支

  从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支上准备上线

- feature/XXXX分支

  从develop上创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支

- hotfix/XXXX分支

  从master派生的分支，一般作为线上bug修复使用，修复完会合并到master，test，develop分支

- 还有一些的别的分支例如test分支（用于测试），pre分支（预上线分支）等等

# 软件测试

## 核心

测试用例的编写

### 测试用例的好处

- 记录问题，发现问题
- 理清思路，避免遗漏
- 跟踪测试进度
- 历史参考
- 重复性
- 告诉领导做过

## 等价划分法

定义：把所有程序的*输入域*划分成若干个*子集合（等价类）*

从每一个子集合（等价类）中选取少数具有代表性的数据作为测试的输入数据

所有的*输入数据*对于揭露软件中的错误都是等效的

### 有效等价类

正面，不报错

### 无效等价类

反面，报错

### 用例设计步骤

1. 分析需求

   确定有效等价类和无效等价类

2. 建立等价类表

   列出所有划分出的等价类

3. 选择测试用例

   多覆盖有效等价类

   仅覆盖一个尚未被覆盖的无效等价类

## 边界值分析法

### 定义

等价类划分法补充边界值从等价类边缘值去寻找

### 原则

确定边界

选取刚刚大于，刚刚小于边界

### 作用

边界法设计测试用例可以查出更多的错误，提出更多的bug

### 方法

两点法

四点法

三点法

### 注意事项

- 次边界值：ip地址(0~200)
- 时间格(0~23)—需求没有常识
- 特殊边界值：0是一个特殊值
- 负数、空值、空格等

## 场景法

### 定义

通过场景描述的业务流程（业务逻辑），也包括代码实现逻辑，设计用例来遍历场景，验证软件系统功能的正确性

### 注意事项

1. 每个流程一个用例验证
2. 流程和功能测试同步完成
3. 针对单步功能进行测试
4. 功能点和流程充分测试

## 错误推测法

### 定义

基于经验和直觉推测所有可能存在各种错误射击测试用例的方法

### 使用步骤

- 不单独使用，使用其他方法补充
- 场景法--业务流程梳理、核心业务逻辑场景
- 等价类和边界值--细化分析
- 错误推测法对最终用例进行错误场景的补充

## 自动化测试

### 意义

- 版本发布频繁方便回归测试
- 自动处理繁琐重复任务
- 提高测试准确性
- 不同版本重复运行

### 自动化测试框架定义

由一些标准，协议，规则组成，提供脚本运行环境

#### 框架设计

- 配置文件
- 框架代码
- 业务页面
- 测试脚本
- 日志报告
- 持续集成

# 关于用到的注解

@Component //在类前注解，将当前类交给IOC容器管理成为，成为容器中的Bean

- @Controller //@Component的衍生注解，标注在控制器类上
- @Service //@Component的衍生注解，标注在业务类上
- @Repository //

@Autowired //在对象前注解，运行时，IOC容器会提供该类型的bean对象，并赋值给该变量

@Mapper // 在运行时，会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器

@Mapper //接口声明，声明是数据库操作接口

@Select("sql语句") //查询操作
